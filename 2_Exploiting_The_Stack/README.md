Exploiting The Stack
==============

First we will take a look at *smash_this.c*, which is our exploitable program. All this program does is read in from a file, and output that to the screen. However, it does this in a very insecure way. Notice that fread() is capable of reading in 0x1000 bytes of data from the file, and will copy this to buffer. The problem is that buffer is only 16 bytes long! This exercise will demonstrate how vulnrabilities such as this can be exploited to run our own code.  

Now lets use the make file to compile the exercise.  

    make -f makefile.mak

This will compile *smash_this.c* into *smash_this.x* and make it's stack executable. These days stacks are set up to be strictly read/write and non-executable to prevent execution of arbitrary code that has been injected by an attacker. The make file also disables Address Space Layout Randomization. ASLR is a obfuscation technique used to make buffer overflows and other exploits more difficult. ASLR randomizes the addresses of as many components in the stack as it can.  

We are assuming we have control over the input text file but we cannot modify smash_this.c in any way. So we will manipulate the input file and see how the program runs. First, run it with the default text in myfile.txt and see what happens. 

Now we will begin using some of these specialized scripts. Using str_pattern.py we will generate a very unique pattern and gdb to see where in the pattern is overwriting the return address. **str_pattern.py* is a python ported version of Metasploit's Ruby scripts *pattern_create.rb* and *pattern_find.rb*

    $ python str_pattern.txt 64
      
