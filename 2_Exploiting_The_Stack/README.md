Exploiting The Stack
==============

First we will take a look at *smash_this.c*, which is our exploitable program. All this program does is read in from a file, count the number of characters, then output that number. However, it does this in a very insecure way. Notice that fread() is capable of reading in 0x1000 bytes of data from the file, and will copy this to buffer. The problem is that buffer is only 48 bytes long! This exercise will demonstrate how vulnrabilities such as this can be exploited to run our own code. (Usually opening a shell) 

Now lets use the make file to compile the exercise.  

    make -f makefile.mak

This will compile *smash_this.c* into *smash_this.x* and make it's stack executable. These days stacks are set up to be strictly read/write and non-executable to prevent execution of arbitrary code that has been injected by an attacker. The make file also disables Address Space Layout Randomization. ASLR is a obfuscation technique used to make buffer overflows and other exploits more difficult. ASLR randomizes the addresses of as many components in the stack as it can.  

We are assuming we have control over the input text file but we cannot modify smash_this.c in any way. So we will manipulate the input file and see how the program runs. First, run it with the default text in myfile.txt and see what happens. 

    $ ./smash_this.x textfile.txt
    <Output from file>

Now we will begin using some of these specialized scripts. Using str_pattern.py we will generate a very unique pattern and gdb to see where in the pattern is overwriting the return address. **str_pattern.py* is a python ported version of Metasploit's Ruby scripts *pattern_create.rb* and *pattern_find.rb*

    $ python str_pattern.py 128

Since we know *smash_this.c* reads gets its input from a file, we will create a text file with the pattern generated by the above script. Next, run our program with the text file as input. If the string we generated is long enough to run into the stack's return address field we should see a segmentation fault. If not, then try generating a longer string.

    $ ./smash_this.x textfile.txt
    Segmentation fault

Now we will run the file with gdb. 

    $ gdb smash_this.x
    (gdb) run textfile.txt

You should see an output error that looks like this:

    Program received signal SIGSEGV, Segmentation fault.
    0x33634132 in ?? ()

The hexidecimal string 0x33634132 is the value of the return address in our stack. If we overflowed the return address correctly we will find this hex pattern in the string generated by our python script. However, since we are running on an intel machine we need to flip the bytes in the hex string. This is because intel processors have a little-endian architecture, but the hex string is printed in the big-endian form. After flipping the bytes, just run the python script with the hex string as the input. (Remeber, in hex every two digits is a byte)

    $ python str_pattern.py 0x32416333
    -------------------------------------------------------------------------
    First location: 68
    ASCII String: 2Ac3
    -------------------------------------------------------------------------

Now we know exactly what characters in our pattern string are being written to the return address in the stack. So, we can replace these characters with specific code to open a shell.

First we will need to search through the *smash_this.x* binary file for a 'jmp esp' instruction. Recall from 'Understanding The Stack' that the esp is the stack pointer, which points just beyond the return address. So, if we overflow the return address with the address of a 'jmp esp', it will jump to that address, then jump back to our stack and execute whatever code happens to be there. (It will be our code that opens a shell)  

We will use *msfelfscan.rb* to scan through the binary. It will look something like this:

    $ ruby msfelfscan.rb -j esp smash_this.x
    [smash_this.x]
    ...
    0x080e261b jmp esp
    0x080e67d8 push esp; retn 0x0000
    0x080e68d8 push esp; ret
    0x080e6d4b jmp esp
    ...

We can use either of the 'jmp esp' addresses and it will work the same. We will have to use a python script at this point to write the hex address and shell code to our attack file. To see how to do this in detail, check out *exploiter.py* in this repository.

    $ python exploiter.py

Now we should be able to run *smash_this.x* and open a shell.

    ~ $ ./smash_this.x shell.txt
    <output from file>
    $ whoami
    admin
    $ 

We can do many other things with this exploit besides open a shell. However, it is easy to see how powerful a memory corruption exploit can be. It only takes one vulnerable program running under a privilaged user for an attacker to take full control of a machine. 
