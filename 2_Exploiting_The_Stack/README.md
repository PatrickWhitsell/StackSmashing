Exploiting The Stack
==============

First we will take a look at *smash_this.c*, which is our exploitable program. All this program does is read in from a file, and output that to the screen. However, it does this in a very insecure way. Notice that fread() is capable of reading in 0x1000 bytes of data from the file, and will copy this to buffer. The problem is that buffer is only 48 bytes long! This exercise will demonstrate how vulnrabilities such as this can be exploited to run our own code.  

Now lets use the make file to compile the exercise.  

    make -f makefile.mak

This will compile *smash_this.c* into *smash_this.x* and make it's stack executable. These days stacks are set up to be strictly read/write and non-executable to prevent execution of arbitrary code that has been injected by an attacker. The make file also disables Address Space Layout Randomization. ASLR is a obfuscation technique used to make buffer overflows and other exploits more difficult. ASLR randomizes the addresses of as many components in the stack as it can.  

We are assuming we have control over the input text file but we cannot modify smash_this.c in any way. So we will manipulate the input file and see how the program runs. First, run it with the default text in myfile.txt and see what happens. 

    $ ./smash_this.x textfile.txt
    <Output from file>

Now we will begin using some of these specialized scripts. Using str_pattern.py we will generate a very unique pattern and gdb to see where in the pattern is overwriting the return address. **str_pattern.py* is a python ported version of Metasploit's Ruby scripts *pattern_create.rb* and *pattern_find.rb*

    $ python str_pattern.py 128

Since we know *smash_this.c* reads gets its input from a file, we will create a text file with the pattern generated by the above script. Next, run our program with the text file as input. If the string we generated is long enough to run into the stack's return address field we should see a segmentation fault. If not, then try generating a longer string.

    $ ./smash_this.x textfile.txt
    Segmentation fault

Now we will run the file with gdb. 

    $ gdb smash_this.x
    (gdb) run textfile.txt

You should see an output error that looks like this:

    Program received signal SIGSEGV, Segmentation fault.
    0x63413163 in ?? ()

The hexidecimal string 0x63413163 is the value of the return address in our stack. If we overflowed the return address correctly we will find this hex pattern in the string generated by our python script. However, since we are running on an intel machine we need to flip the bytes in the hex string. This is because intel processors have a little-endian architecture, but the hex string is printed in the big-endian form. After flipping the bytes, just run the python script with the hex string as the input.

    $ python str_pattern.py 0x63314163
    -------------------------------------------------------------------------
    First location: 64
    -------------------------------------------------------------------------





